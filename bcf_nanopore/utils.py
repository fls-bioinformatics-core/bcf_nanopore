#!/usr/bin/env python3
#
#     utils.py: utility classes and functions
#     Copyright (C) University of Manchester 2024-2025 Peter Briggs
#

"""
Utility classes and functions
"""

import os
import logging
from auto_process_ngs.simple_scheduler import SchedulerJob
from bcftbx.TabFile import TabFile

# Module specific logger
logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


class MetadataTabFile(TabFile):
    """
    Base class for metadata files storing one entry per line
 
    Provides a base class for creating and manipulating TSV-based
    metadata files with one entry per line and columns holding
    the data items for that entry.

    For example a file with sample information:

    #Sample	Barcode	Flowcell
    GR1	NB03	PAW14486
    GR2	NB04	PAW14486
    ...

    An appropriate class for handling these data can be easily
    created by subclassing this class:

    >>> class SampleInfo(MetadataTabFile):
    ...     def __init__(self):
    ...        MetadataTabFile.__init__(self,
    ...                                 fields=['Sample',
    ...                                         'Barcode',
    ...                                         'Flowcell'],
    ...                                 kwmap={ 'Sample': 'sample_name',
    ...                                         'Barcode': 'barcode_id',
    ...                                         'Flowcell': 'flow_cell_id' },
    ...                                 index_field='Sample')

    'fields' defines the columns in the file; 'kwmap' maps the column
    names to keyword names used for setting the values via the
    'add_entry' and 'update_entry' methods; 'index_field' specifies the
    field to be used as the index for entries.

    Any fields not specified in 'kwmap' will have an implicit mapping
    generated by setting the field name to lower case and transforming
    spaces to underscores (e.g. 'Sample Name' will be mapped to
    'sample_name').

    If 'index_field' is not supplied then the first field is
    automatically used as the index field. Values in the index field
    column must be unique through the file.

    Any fields set to None will be written to file with a '.'
    placeholder.

    The following methods are then available:

    * 'add_entry' adds a new data line;
    * 'update_entry' allows an existing line to be modified
    * 'lookup_entry' allows an entry to be retrieved
    * 'save' writes the data to a file

    Arguments:
      fields (list): list of fields (i.e. columns)
      keymap (dict): optional, if supplied then explicitly specifies
        parameter names to map to some or all of the fields
      index_field (str): optional, if supplied then explicitly
        specifies the field to use for indexing
      sort_func (object): optional, if supplied then specifies the
        function to be evaluated on each entry for comparison
        purposes when sorting entries before saving
      filein: (optional) name of an existing file to read data from
    """

    def __init__(self, fields, keymap=None, index_field=None,
                 sort_func=None, filein=None):
        # List of fields
        self._default_fields = tuple(fields)
        # Map keywords to column names
        self._keymap = {
            f: convert_field_name(f)
            for f in self._default_fields
        }
        if keymap:
            for k in keymap:
                self._keymap[k] = keymap[k]
        # Index field
        if index_field:
            if index_field not in self._default_fields:
                raise KeyError(f"'{index_field}%s': index field not found")
            self._index_field = index_field
        else:
            self._index_field = self._default_fields[0]
        # Sort function
        if sort_func:
            self._sort_key = sort_func
        else:
            self._sort_key = self.__default_sort_key
        # Optional file to read from
        self.__filein = filein
        if self.__filein is None:
            # No existing file so set the default
            # fields to write to the file
            self._fields = self._default_fields
        else:
            # Get columns from existing file
            with open(self.__filein, 'r') as fp:
                header = fp.readline()
                self._fields = header.rstrip('\n').lstrip('#').split('\t')
        # Open the file
        TabFile.__init__(self, filen=self.__filein,
                         column_names=self._fields,
                         skip_first_line=True,
                         convert=False,
                         keep_commented_lines=True)
        # Add any missing columns
        for field in self._default_fields:
            if field not in self._fields:
                self.appendColumn(field)

    @property
    def index(self):
        """
        Fetch the index field keyword

        Returns:
          String: name of the index field keyword.
        """
        return self._index_field

    def add_entry(self, name, **kws):
        """
        Add an entry to the file

        Arguments:
          name (str): name associated with the entry (will
            be associated with the index field)
          kws (mapping): assigns values to parameter names
            that map to the column names
        """
        # Check entry not already present
        if name in self:
            raise Exception("'%s': entry already exists" % name)
        # Create an empty data line for the entry
        entry = self.append()
        # Add the index field
        entry[self.index] = name
        # Assign the data
        for field in self._fields:
            # Ignore the index field (already set above)
            if field == self.index:
                continue
            # Identify the keyword parameter for this field
            try:
                kw = self._keymap[field]
            except KeyError:
                raise KeyError(f"Unrecognised field: '{field}'")
            # Look up the assigned value
            try:
                value = kws[kw]
            except KeyError:
                value = None
            # Set value in the data line
            if value is None:
                entry[field] = '.'
            else:
                entry[field] = value

    def update_entry(self, name, **kws):
        """
        Add an existing entry in the file

        Arguments:
          name (str): name associated with the entry (will
            be associated with the index field)
          kws (mapping): assigns values to parameter names
        """
        # Fetch data line for existing project
        entry = self.lookup_entry(name)
        # Update the data
        for field in self._fields:
            # Identify the keyword parameter for this field
            try:
                kw = self._keymap[field]
            except KeyError:
                raise KeyError(f"Unrecognised field: '{field}'")
            # Assign the new values
            if kw not in kws:
                continue
            value = kws[kw]
            # Set value in the data line
            if value is None:
                entry[field] = '.'
            else:
                entry[field] = value

    def lookup_entry(self, name):
        """
        Fetch an entry matching the specified index value

        Arguments:
          name (str): index of entry to fetch

        Returns:
          TabDataLine: retrieved entry

        Raises:
          KeyError: if the supplied index doesn't match any
            entry.
        """
        base_name = name.lstrip('#')
        for entry_name in (base_name, f"#{base_name}"):
            try:
                return TabFile.lookup(self,
                                      self.index,
                                      entry_name)[0]
            except IndexError:
                pass
        raise KeyError(f"'{name}': key not found in metadata file")

    def save(self, fileout=None):
        """
        Save the data to file

        Arguments:
          fileout: name of the file to save to (if not specified
            then defaults to the same file as data was read in
            from)
        """
        # Sort into index key order
        self.sort(self._sort_key)
        # Write to file
        if fileout is not None:
            self.__filein = fileout
        self.write(filen=self.__filein, include_header=True)

    def __default_sort_key(self, entry):
        """
        Internal: default function to generate sort key for entries

        Default sort key is the value of the index field.
        """
        return str(entry[self.index].lstrip('#'))

    def __contains__(self, name):
        """
        Internal: check if entry matching index 'name' exists

        Arguments:
          name (str): index value to check for matching entry
        """
        return (name.lstrip('#') in
                [entry[self.index].lstrip('#')
                 for entry in self])


def execute_command(cmd, runner=None, jobname=None):
    """
    Execute a command and return the exit status

    Executes the supplied Command instance either
    using the ``subprocess`` module, or via a
    JobRunner instance (if one is supplied).

    Arguments:
      cmd (Command): command to execute
      runner (JobRunner): optional, job runner
        instance to use to execute the command
      jobname (str): optional, name for the job
        (if using a job runner)

    Returns:
      Integer: exit status of the executed command.
    """
    if jobname is None:
        jobname = cmd.command
    if runner is None:
        # Job execution via subprocess
        log = f"{jobname}.log"
        try:
            exit_code = cmd.run_subprocess(log=log)
        finally:
            # Print and remove log
            if os.path.exists(log):
                with open(log, "rt") as fp:
                    print(fp.read())
                os.remove(log)
            return exit_code
    else:
        # Job execution via a runner
        job = SchedulerJob(runner,
                           cmd.command_line,
                           name=f"{jobname}")
        job.start()
        try:
            # Wait for job to finish
            job.wait()
        except KeyboardInterrupt as ex:
            # Terminated by Ctrl-C
            logger.warning(f"Keyboard interrupt: terminating "
                           f"'{cmd.command} ...'")
            job.terminate()
        finally:
            # Print and remove logs
            for log in (job.log, job.err):
                if log and os.path.exists(log):
                    with open(log, "rt") as fp:
                        print(fp.read())
                    os.remove(log)
        return job.exit_code


def fmt_value(value, none='?'):
    """
    Convert 'None' values to '?' for display

    Arguments:
      value (object): value to convert
      none (str): alternative value to display
        if 'value' is None

    Returns:
      Object: '?' if supplied object is None, otherwise
        returns the original object unmodified.
    """
    return none if value is None else value


def fmt_yes_no(value):
    """
    Return 'no' if value is 'None' or 'yes' otherwise.

    Arguments:
      value (object): value to convert

    Returns:
      Object: 'no' if supplied object is None, otherwise
        returns 'yes'.
    """
    return 'no' if value is None else 'yes'


def convert_field_name(name):
    """
    Convert a field (column) name to a parameter name

    Given a field name, conversion is as follows:

    - Spaces are converted to underscores
    - Camel-case names have underscored inserted between 'words'
    - All characters are converted to lower case

    So for example:

    - 'Run' -> 'run'
    - 'Project name' -> 'project_name'
    - 'FlowCellID' -> 'flow_cell_id'

    Arguments:
      name (str): name to convert

    Returns:
      String: converted name.
    """
    name_ = ''
    prev_char = ''
    for c in name:
        if name_:
            if not c.isalnum():
                c = "_"
            elif c.isupper() and prev_char.islower():
                name_ += "_"
        if c != "_" or name_[:-1] != "_":
            name_ += c.lower()
        prev_char = c
    return name_
